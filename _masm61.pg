module
  : directiveList?  endDir
  ; 
lineReminder
  :comment? endOfLine
  ; 
eqDir
  :id "=" immExpr lineReminder
  ; 
addOp
  :"+" | "-"
  ; 
aExpr
  : term "&&" aExpr | term
  ; 
altId
  :id
  ; 
arbitraryText
  :charList
  ; 
asmInstruction
  :mnemonic  exprList? 
  ; 
assumeDir
  :"ASSUME" assumeList lineReminder| "ASSUME NOTHING" lineReminder
  ; 
assumeList 
  :assumeRegister| assumeRegister "," assumeList
  ; 
assumeReg
  :register ":" assumeVal
  ; 
assumeRegister
  :assumeSegReg| assumeReg
  ; 
assumeSegReg
  :segmentRegister ":" assumeSegVal
  ; 
assumeSegVal
  : "NOTHING" | "ERROR" | frameExpr
  ; 
assumeVal
  : "NOTHING" | "ERROR" | qualifiedType
  ; 
bcdConst
  : sign?  decNumber
  ; 
binaryOp
  :"=="| "!="| ">="| "<="| ">"| "<"| "&" 
  ; 
eqconstExpr
  :"=" constExpr
  ;
bitDef
  :bitFieldId ":" bitFieldSize eqconstExpr?
  ; 
bitDefList
  :bitDef| bitDef "," lineReminder? bitDefList
  ; 
bitFieldId 
  :id 
  ; 
bitFieldSize
  :constExpr
  ; 
ifcexpr
  :_IF cExpr
  ;
blockStatements
  : _CONTINUE ifcexpr? | _BREAK ifcexpr? | directiveList
  ; 
bool
  :"TRUE" | "FALSE" 
  ; 
byteRegister
  :'AL' | 'AH' | 'BL' | 'BH' | 'CL' | 'CH' | 'DL' | 'DH' 
  ; 
cExpr
  : aExpr ":" cExpr | aExpr
  ; 
charList
  : character+
  ; 
className
  :string
  ; 
commDecl
  : nearfar?   langType?  id ":" commType eqconstExpr?
  ; 
commDir
  :"COMM" commList lineReminder
  ; 
commentDir
  :"COMMENT" delimiter text text delimiter text lineReminder
  ; 
commList
  :commDecl| commDecl "," commList
  ; 
commType
  : type | constExpr
  ; 
constant
  :digits  radixOverride? 
  ; 
constExpr
  :expr
  ; 
contextDir
  :"PUSHCONTEXT" contextItemList lineReminder| "POPCONTEXT" contextItemList lineReminder
  ; 
contextItem
  :"ASSUMES" | "RADIX" | "LISTING" | "CPU" | "ALL" 
  ; 
contextItemList
  :contextItem| contextItem "," contextItemList
  ; 
controlBlock
  :whileBlock| repeatBlock
  ; 
controlDir
  :controlIf| controlBlock
  ; 
controlElseif
  :_ELSEIF cExpr lineReminder directiveList controlElseif? 
  ; 

elsedirectiveList
  :_ELSE lineReminder directiveList
  ;
controlIf
  :_IF cExpr lineReminder directiveList controlElseif? elsedirectiveList? _ENDIF lineReminder
  ; 
coprocessor
  :_8087 | _287 | _387 | _NO87 
  ; 
crefDir
  :crefOption lineReminder
  ; 
crefOption
  :_CREF | _XCREF idList? | _NOCREF idList? 
  ; 
cxzExpr
  : "!" expr| expr  "==" expr| expr  "!=" expr | expr
  ; 
dataDecl
  :"DB" | "DW" | "DD" | "DF" | "DQ" | "DT" | dataType | typeId
  ; 
dataDir
  : id?  dataItem lineReminder
  ; 
dataItem
  :dataDecl scalarInstList| structTag structInstList| typeId structInstList| unionTag structInstList| recordTag recordInstList
  ; 
dataType
  :"BYTE" | "SBYTE" | "WORD" | "SWORD" | "DWORD" | "SDWORD" | "FWORD" | "QWORD" | "TBYTE" | "REAL4" | "REAL8" | "REAL10" 
  ; 
decNumber
  :decdigit+
  ; 
digits
  :decdigit+| digits hexdigit
  ; 
directive
  :generalDir| segmentDef
  ; 
directiveList
  :directive+
  ; 
distance
  :nearfar| "NEAR16" | "NEAR32" | "FAR16" | "FAR32" 
  ; 
e01
  :e01 orOp e02| e02
  ; 
e02
  :e02 "AND" e03| e03
  ; 
e03
  :"NOT" e04| e04
  ; 
e04
  :e04 relOp e05| e05
  ; 
e05
  :e05 addOp e06| e06
  ; 
e06
  :e06 mulOp e07| e06 shiftOp e07| e07
  ; 
e07
  :e07 addOp e08| e08
  ; 
e08
  :"HIGH" e09| "LOW" e09| "HIGHWORD" e09| "LOWWORD" e09| e09
  ; 
e09
  :"OFFSET" e10| "SEG" e10| "LROFFSET" e10| "TYPE" e10| "THIS" e10| e09 "PTR" e10| e09 ":" e10| e10
  ; 
e10
  :e10 _DOT e11| e10 expr | e11
  ; 
e11
  :"(" expr ")" | "WIDTH" id| "MASK" id| "SIZE" sizeArg| "SIZEOF" sizeArg| "LENGTH" id| "LENGTHOF" id | recordConst| string| constant| type| id| "$"| segmentRegister| register| "ST" | "ST" "(" expr ")" | expr
  ; 
echoDir
  :"ECHO" arbitraryText lineReminder "%OUT" arbitraryText lineReminder
  ; 
elseifBlock
  :elseifStatement lineReminder directiveList elseifBlock? 
  ; 
elseifStatement
  :"ELSEIF" constExpr| "ELSEIFE" constExpr| "ELSEIFB" textItem| "ELSEIFNB" textItem | "ELSEIFDEF" id| "ELSEIFNDEF" id| "ELSEIFDIF" textItem "," textItem| "ELSEIFDIFI" textItem "," textItem| "ELSEIFIDN" textItem "," textItem| "ELSEIFIDNI" textItem "," textItem| "ELSEIF1" | "ELSEIF2" 
  ; 
endDir
  :"END" immExpr?  lineReminder?
  ; 
endpDir
  :procId "ENDP" lineReminder
  ; 
endsDir
  :id "ENDS" lineReminder
  ; 
equDir
  :textMacroId "EQU" equType lineReminder
  ; 
equType
  :immExpr| textLiteral
  ; 
errorDir
  :errorOpt lineReminder
  ; 
errorOpt
  :_ERR textItem? | _ERRE constExpr optText? | _ERRNZ constExpr optText? | _ERRB textItem optText? | _ERRNB textItem optText? | _ERRDEF id  optText? | _ERRNDEF id optText? | _ERRDIF textItem "," textItem  optText? | _ERRDIFI textItem "," textItem  optText? | _ERRIDN textItem "," textItem  optText? | _ERRIDNI textItem "," textItem  optText? | _ERR1 textItem? | _ERR2 textItem?  
  ; 
exitDir
  :_EXIT expr?  lineReminder
  ; 
exitmDir
  :"EXITM" | "EXITM" textItem
  ; 
exponent
  :"E"  sign?  decNumber
  ; 
expr
  :"SHORT" e05| _TYPE e01| "OPATTR" e01| e01
  ; 
exprList
  : expr | expr  ","  exprList
  ; 
altIdq
  :"(" altId ")"
  ;
externDef
  : langType?  id altIdq? ":" externType
  ; 
externDir
  :externKey externList lineReminder
  ; 
externKey
  :"EXTRN" | "EXTERN" | "EXTERNDEF" 
  ; 
externList
  :externDef| externDef  "," lineReminder?  externList
  ; 
externType
  :"ABS" | qualifiedType
  ; 
fieldAlign
  :constExpr
  ; 
fieldInit
  : initValue | structInstance
  ; 
fieldInitList
  : fieldInit ","  lineReminder?  fieldInitList | fieldInit
  ; 
fileChar
  :delimiter
  ; 
fileCharList
  :fileChar+
  ; 
fileSpec
  :fileCharList| textLiteral
  ; 
flagName
  :"ZERO? "| "CARRY?" | "OVERFLOW?"|"SIGN?"| "PARITY?"
  ; 
floatNumber 
  : sign?  decNumber _DOT decNumber?   exponent? | digits "R"| digits "r"
  ; 
forcDir
  :"FORC" | "IRPC" 
  ; 
forDir
  :"FOR" | "IRP" 
  ; 
dotdotforParmType
  :":" forParmType
  ;
forParm
  :id dotdotforParmType?
  ; 
forParmType
  :"REQ" | "=" textLiteral
  ; 
frameExpr
  :"SEG" id | "DGROUP" ":" id| segmentRegister ":" id| id
  ; 
generalDir
  :modelDir | segOrderDir | nameDir| includeLibDir | commentDir| groupDir | assumeDir| structDir | recordDir | typedefDir| externDir | publicDir | commDir | protoTypeDir| equDir | eqDir | textDir| contextDir | optionDir | processorDir| radixDir | titleDir | pageDir | listDir | crefDir | echoDir| ifDir | errorDir | includeDir | macroDir | macroCall | macroRepeat | purgeDir| macroWhile | macroFor | macroForc| aliasDir
  ; 
aliasDir
  :"ALIAS"
  ;
gpRegister
  :'AX' | 'EAX' | 'BX' | 'EBX' | 'CX' | 'ECX' | 'DX' | 'EDX'| 'BP' | 'EBP' | 'SP' | 'ESP' | 'DI' | 'EDI' | 'SI' | 'ESI'
  ; 
groupDir 
  :groupId "GROUP" segIdList
  ; 
groupId
  :id
  ; 
idList
  : id "," idList | id
  ; 
ifDir
  :ifStatement lineReminder directiveList elseifBlock? elsedirectiveList? "ENDIF" lineReminder
  ; 
ifStatement
  :"IF" constExpr| "IFE" constExpr| "IFB" textItem| "IFNB" textItem| "IFDEF" id| "IFNDEF" id| "IFDIF" textItem "," textItem| "IFDIFI" textItem "," textItem| "IFIDN" textItem "," textItem| "IFIDNI" textItem "," textItem| "IF1" | "IF2" 
  ; 
immExpr
  :expr
  ; 
includeDir
  :"INCLUDE" fileSpec lineReminder
  ; 
includeLibDir
  :"INCLUDELIB" fileSpec lineReminder
  ; 
initValue
  :immExpr| string| "?"| constExpr  "DUP" "(" scalarInstList ")"| floatNumber| bcdConst
  ; 
inSegDir
  : labelDef?  inSegmentDir
  ; 
inSegDirList
  :inSegDir+
  ; 
inSegmentDir
  :instruction| dataDir| controlDir| startupDir| exitDir| offsetDir| labelDir| procDir  localDirList?   inSegDirList?  endpDir| invokeDir| generalDir 
  ; 
instrPrefix
  :"REP" | "REPE" | "REPZ" | "REPNE" | "REPNZ" | "LOCK" 
  ; 
instruction
  : instrPrefix?  asmInstruction
  ; 
invokeArg
  :register "::" register| "ADDR" expr | expr
  ; 
commainvokeList
  :"," lineReminder? invokeList
  ;
invokeDir
  :"INVOKE" expr commainvokeList? lineReminder
  ; 
invokeList
  : invokeArg  "," lineReminder?  invokeList | invokeArg
  ; 
labelDef
  :id ":" | id "::" | "@@:"
  ; 
labelDir
  :id "LABEL" qualifiedType lineReminder
  ; 
langType
  :"C" | "PASCAL" | "FORTRAN" | "BASIC" | "SYSCALL" | "STDCALL" 
  ; 
listDir
  :listOption lineReminder
  ; 
listOption
  :_LIST | _NOLIST | _XLIST | _LISTALL | _LISTIF | _LFCOND | _NOLISTIF | _SFCOND | _TFCOND | _LISTMACROALL | _LALL | _NOLISTMACRO | _SALL | _LISTMACRO | _XALL 
  ; 
localDef
  :"LOCAL" idList lineReminder
  ; 
localDir
  :"LOCAL" parmList lineReminder
  ; 
localDirList
  :localDir+
  ; 
localList
  :localDef+
  ; 
macroArg
  :"%" constExpr| "%" textMacroId| "%" macroFuncId "(" macroArgList ")"| string| "<" arbitraryText ">" | arbitraryText
  ; 
macroArgList
  : macroArg  "," macroArgList | macroArg
  ; 
macroBody
  : localList? macroStmtList
  ; 
macroCall
  : id  "(" macroArgList ")" | id macroArgList lineReminder
  ; 
macroDir
  :id "MACRO" macroParmList?  lineReminder macroBody "ENDM" lineReminder
  ; 
macroFor
  :forDir forParm  "," "<" macroArgList ">" lineReminder macroBody "ENDM" lineReminder
  ; 
macroForc
  :forcDir id  "," textLiteral lineReminder macroBody "ENDM" lineReminder
  ; 
macroFuncId
  :id
  ; 
macroId
  :macroProcId| macroFuncId
  ; 
macroIdList
  : macroId  ","  macroIdList | macroId
  ; 
macroLabel
  :id
  ; 
dotdotparmType
  :":" parmType
  ;
macroParm
  :id dotdotparmType?
  ; 
macroParmList
  : macroParm  "," lineReminder?  macroParmList | macroParm
  ; 
macroProcId
  :id
  ; 
macroRepeat
  :repeatDir constExpr lineReminder macroBody "ENDM" lineReminder
  ; 
macroStmt
  :directive| exitmDir| ":" macroLabel| "GOTO" macroLabel
  ; 
macroStmtList
  : macroStmt macroStmtList | macroStmt lineReminder
  ; 
macroWhile
  :"WHILE" constExpr lineReminder macroBody "ENDM" lineReminder
  ; 
mapType
  :"ALL" | "NONE" | "NOTPUBLIC" 
  ; 
memOption
  :"TINY" | "SMALL" | "MEDIUM" | "COMPACT" | "LARGE" | "HUGE" | "FLAT" 
  ; 
mnemonic
  : "AAA"|
    "AAD"|
    "AAM"|
    "AAS"|
    "ADC"|
    "ADD"|
    "AND"|
    "CALL"|
    "CBW"|
    "CLC"|
    "CLD"|
    "CLI"|
    "CMC"|
    "CMP"|
    "CMPS"|
    "CMPSB"|
    "CMPSW"|
    "CWD"|
    "DAA"|
    "DAS"|
    "DEC"|
    "DIV"|
    "ESC"|
    "HLT"|
    "IDIV"|
    "IMUL"|
    "IN"|
    "INC"|
    "INT"|
    "INTO"|
    "IRET"|
    "JA"|
    "JAE"|
    "JB"|
    "JBE"|
    "JC"|
    "JCXZ"|
    "JE"|
    "JG"|
    "JGE"|
    "JL"|
    "JLE"|
    "JMP"|
    "JNA"|
    "JNAE"|
    "JNB"|
    "JNBE"|
    "JNC"|
    "JNE"|
    "JNG"|
    "JNGE"|
    "JNL"|
    "JNLE"|
    "JNO"|
    "JNP"|
    "JNS"|
    "JNZ"|
    "JO"|
    "JP"|
    "JPE"|
    "JPO"|
    "JS"|
    "JZ"|
    "LAHF"|
    "LDS"|
    "LEA"|
    "LES"|
    "LODS"|
    "LODSB"|
    "LODSW"|
    "LOOP"|
    "LOOPE"|
    "LOOPEW"|
    "LOOPNE"|
    "LOOPNEW"|
    "LOOPNZ"|
    "LOOPNZW"|
    "LOOPW"|
    "LOOPZ"|
    "LOOPZW"|
    "MOV"|
    "MOVS"|
    "MOVSB"|
    "MOVSW"|
    "MUL"|
    "NEG"|
    "NOP"|
    "NOT"|
    "OR"|
    "OUT"|
    "POP"|
    "POPF"|
    "PUSH"|
    "PUSHF"|
    "RCL"|
    "RCR"|
    "RET"|
    "RETF"|
    "RETN"|
    "ROL"|
    "ROR"|
    "SAHF"|
    "SAL"|
    "SAR"|
    "SBB"|
    "SCAS"|
    "SCASB"|
    "SCASW"|
    "SHL"|
    "SHR"|
    "STC"|
    "STD"|
    "STI"|
    "STOS"|
    "STOSB"|
    "STOSW"|
    "SUB"|
    "TEST"|
    "WAIT"|
    "XCHG"|
    "XLAT"|
    "XLATB"|
    "XOR"|
    "BOUND"|
    "ENTER"|
    "INS"|
    "INSB"|
    "INSW"|
    "LEAVE"|
    "OUTS"|
    "OUTSB"|
    "OUTSW"|
    "POPA"|
    "PUSHA"|
    "PUSHW"|
    "ARPL"|
    "LAR"|
    "LSL"|
    "SGDT"|
    "SIDT"|
    "SLDT"|
    "SMSW"|
    "STR"|
    "VERR"|
    "VERW"|
    "CLTS"|
    "LGDT"|
    "LIDT"|
    "LLDT"|
    "LMSW"|
    "LTR"|
    "BSF"|
    "BSR"|
    "BT"|
    "BTC"|
    "BTR"|
    "BTS"|
    "CDQ"|
    "CMPSD"|
    "CWDE"|
    "INSD"|
    "IRETD"|
    "IRETDF"|
    "IRETF"|
    "JECXZ"|
    "LFS"|
    "LGS"|
    "LODSD"|
    "LOOPD"|
    "LOOPED"|
    "LOOPNED"|
    "LOOPNZD"|
    "LOOPZD"|
    "LSS"|
    "MOVSD"|
    "MOVSX"|
    "MOVZX"|
    "OUTSD"|
    "POPAD"|
    "POPFD"|
    "PUSHAD"|
    "PUSHD"|
    "PUSHFD"|
    "SCASD"|
    "SETA"|
    "SETAE"|
    "SETB"|
    "SETBE"|
    "SETC"|
    "SETE"|
    "SETG"|
    "SETGE"|
    "SETL"|
    "SETLE"|
    "SETNA"|
    "SETNAE"|
    "SETNB"|
    "SETNBE"|
    "SETNC"|
    "SETNE"|
    "SETNG"|
    "SETNGE"|
    "SETNL"|
    "SETNLE"|
    "SETNO"|
    "SETNP"|
    "SETNS"|
    "SETNZ"|
    "SETO"|
    "SETP"|
    "SETPE"|
    "SETPO"|
    "SETS"|
    "SETZ"|
    "SHLD"|
    "SHRD"|
    "STOSD"|
    "BSWAP"|
    "CMPXCHG"|
    "INVD"|
    "INVLPG"|
    "WBINVD"|
    "XADD"|
    "F2XM1"|
    "FABS"|
    "FADD"|
    "FADDP"|
    "FBLD"|
    "FBSTP"|
    "FCHS"|
    "FCLEX"|
    "FCOM"|
    "FCOMP"|
    "FCOMPP"|
    "FDECSTP"|
    "FDISI"|
    "FDIV"|
    "FDIVP"|
    "FDIVR"|
    "FDIVRP"|
    "FENI"|
    "FFREE"|
    "FIADD"|
    "FICOM"|
    "FICOMP"|
    "FIDIV"|
    "FIDIVR"|
    "FILD"|
    "FIMUL"|
    "FINCSTP"|
    "FINIT"|
    "FIST"|
    "FISTP"|
    "FISUB"|
    "FISUBR"|
    "FLD"|
    "FLD1"|
    "FLDCW"|
    "FLDENV"|
    "FLDENVW"|
    "FLDL2E"|
    "FLDL2T"|
    "FLDLG2"|
    "FLDLN2"|
    "FLDPI"|
    "FLDZ"|
    "FMUL"|
    "FMULP"|
    "FNCLEX"|
    "FNDISI"|
    "FNENI"|
    "FNINIT"|
    "FNOP"|
    "FNSAVE"|
    "FNSAVEW"|
    "FNSTCW"|
    "FNSTENV"|
    "FNSTENVW"|
    "FNSTSW"|
    "FPATAN"|
    "FPREM"|
    "FPTAN"|
    "FRNDINT"|
    "FRSTOR"|
    "FRSTORW"|
    "FSAVE"|
    "FSAVEW"|
    "FSCALE"|
    "FSQRT"|
    "FST"|
    "FSTCW"|
    "FSTENV"|
    "FSTENVW"|
    "FSTP"|
    "FSTSW"|
    "FSUB"|
    "FSUBP"|
    "FSUBR"|
    "FSUBRP"|
    "FTST"|
    "FWAIT"|
    "FXAM"|
    "FXCH"|
    "FXTRACT"|
    "FYL2X"|
    "FYL2XP1"|
    "FSETPM"|
    "FCOS"|
    "FLDENVD"|
    "FNSAVED"|
    "FNSTENVD"|
    "FPREM1"|
    "FRSTORD"|
    "FSAVED"|
    "FSIN"|
    "FSINCOS"|
    "FSTENVD"|
    "FUCOM"|
    "FUCOMP"|
    "FUCOMPP"
  ; 
commamodelOptlist
  :"," modelOptlist
  ;
modelDir
  :_MODEL memOption commamodelOptlist? lineReminder
  ; 
modelOpt
  :langType| stackOption 
  ; 
modelOptlist
  :modelOpt| modelOpt  "," modelOptlist
  ; 
mulOp
  :"*"| "/" | "MOD" 
  ; 
nameDir
  :"NAME" id lineReminder
  ; 
nearfar
  :"NEAR" | "FAR" 
  ; 
nestedStruct
  :structHdr  id?  lineReminder structBody "ENDS" lineReminder
  ; 
offsetDir
  :offsetDirType lineReminder
  ; 
offsetDirType
  :"EVEN" | "ORG" immExpr| "ALIGN" constExpr? 
  ; 
offsetType
  :"GROUP" | "SEGMENT" | "FLAT" 
  ; 
oldRecordFieldList
  : constExpr "," oldRecordFieldList | constExpr
  ; 
optionDir
  :"OPTION" optionList lineReminder
  ; 
readonly
  :"READONLY"
  ;
optionItem
  :"CASEMAP" ":" mapType| "DOTNAME" | "NODOTNAME" | "EMULATOR" | "NOEMULATOR" | "EPILOGUE" ":" macroId| "EXPR16" | "EXPR32" | "LANGUAGE" ":" langType| "LJMP" | "NOLJMP" | "M510" | "NOM510" | "NOSIGNEXTEND" | "OFFSET" ":" offsetType| "OLDMACROS" | "NOOLDMACROS" | "OLDSTRUCTS" | "NOOLDSTRUCTS" | "PROC" ":" oVisibility| "PROLOGUE" ":" macroId| readonly | "NOREADONLY" | "SCOPED" | "NOSCOPED" | "SEGMENT" ":" segSize| "SETIF2" ":" bool
  ; 
optionList
  :optionItem| optionItem  "," lineReminder?  optionList
  ; 
optText
  :"," textItem
  ; 
orOp
  :"OR" | "XOR" 
  ; 
oVisibility
  :"PUBLIC" | "PRIVATE" | "EXPORT" 
  ; 
pageDir
  :"PAGE" pageExpr?  lineReminder
  ; 
commapageWidth
  :"," pageWidth
  ;
pageExpr
  :"+"|  pageLength?  commapageWidth?
  ; 
pageLength
  :constExpr
  ; 
pageWidth
  :constExpr
  ; 
dotdotqualifiedType
  :":" qualifiedType
  ;
parm
  : parmId  constExpr? dotdotqualifiedType?
  ; 
parmId
  :id
  ; 
parmList
  : parm  "," lineReminder? parmList | parm
  ; 
parmType
  :"REQ" | "=" textLiteral| "VARARG" 
  ; 
pOptions
  : distance?   langType?   oVisibility? 
  ; 
primary
  :expr binaryOp expr| flagName| expr
  ; 
brmacroArgList
  :"<" macroArgList ">"
  ;
procDir
  :procId "PROC" pOptions?  brmacroArgList?  usesRegs?   procParmList? 
  ; 
processor
  :_8086 | _186 | _286 | _286C | _286P | _386 | _386C | _386P | _486 | _486P | _586 | _586P |
 _686 | _686P | _K3D | _MMX | _XMM
  ; 
processorDir
  :processor lineReminder | coprocessor lineReminder
  ; 
procId
  :id
  ; 
commaparmList
  :","  lineReminder?  parmList
  ;
commaparmIdvararg
  :","  lineReminder?  parmId ":VARARG" 
  ;
procParmList
  :commaparmList? 
    commaparmIdvararg?
  ; 
protoArg 
  : id? ":" qualifiedType 
  ; 
commaprotoList
  :","  lineReminder?  protoList
  ;
commaidvararg
  :","  lineReminder?   id? ":VARARG" 
  ;
protoArgList
  :commaprotoList?
    commaidvararg?
  ; 
protoList
  :protoArg| protoArg  "," lineReminder?  protoList
  ; 
protoSpec
  : typeId | distance?   langType?   protoArgList?
  ; 
protoTypeDir
  :id "PROTO" protoSpec
  ; 
pubDef
  : langType?  id
  ; 
publicDir
  :"PUBLIC" pubList lineReminder
  ; 
pubList
  : pubDef  "," lineReminder?  pubList | pubDef
  ; 
purgeDir
  :"PURGE" macroIdList
  ; 
qualifiedType
  :  distance? "PTR" qualifiedType? | type
  ; 
qualifier
  : "PROTO" protoSpec | qualifiedType
  ; 
quote
  :'"' | "'"
  ; 
radixDir
  :_RADIX constExpr lineReminder
  ; 
recordConst
  :recordTag "{" oldRecordFieldList "}"| recordTag "<" oldRecordFieldList ">"
  ; 
recordDir
  :recordTag "RECORD" bitDefList lineReminder 
  ; 
recordFieldList
  : constExpr  ","  lineReminder? recordFieldList | constExpr
  ; 
recordInstance
  :"{"  lineReminder?  recordFieldList  lineReminder?  "}"| "<" oldRecordFieldList ">"| constExpr "DUP" "(" recordInstance ")"
  ; 
recordInstList
  :recordInstance| recordInstance ","  lineReminder?  recordInstList
  ; 
recordTag
  :id
  ; 
register
  :specialRegister| gpRegister| byteRegister
  ; 
regList
  :register+
  ; 
relOp
  :"EQ" | "NE" | "LT" | "LE" | "GT" | "GE" 
  ; 
repeatBlock
  :_REPEAT lineReminder blockStatements lineReminder untilDir lineReminder
  ; 
repeatDir
  :"REPEAT" | "REPT" 
  ; 
scalarInstList
  : initValue ","  lineReminder? scalarInstList | initValue
  ; 
segAlign
  :"BYTE" | "WORD" | "DWORD" | "PARA" | "PAGE" 
  ; 
segAttrib
  :"PUBLIC" | "STACK" | "COMMON" | "MEMORY" | "AT" constExpr| "PRIVATE" 
  ; 
segDir
  :_CODE segId? | _DATA | _DATA_| _CONST | _FARDATA segId? | _FARDATA_ segId? | _STACK constExpr?
  ; 
segId
  :id
  ; 
segIdList 
  : segId  "," segIdList | segId
  ; 
segmentDef
  :segmentDir  inSegDirList?  endsDir| simpleSegDir  inSegDirList?   endsDir? 
  ; 
segmentDir
  :segId "SEGMENT" segOptionList?  lineReminder
  ; 
segmentRegister
  :'CS' | 'DS' | 'ES' | 'FS' | 'GS' | 'SS'
  ; 
segOption
  :segAlign| segRO| segAttrib| segSize| className
  ; 
segOptionList
  :segOption+
  ; 
segOrderDir
  :_ALPHA | _SEQ | _DOSSEG | "DOSSEG" 
  ; 
segRO
  :readonly
  ; 
segSize 
  :"USE16" | "USE32" | "FLAT" 
  ; 
shiftOp
  :"SHR" | "SHL" 
  ; 
sign
  :"-" | "+"
  ; 
simpleExpr
  :"(" cExpr ")"| primary
  ; 
simpleSegDir
  :segDir lineReminder
  ; 
sizeArg
  :id| type| e10
  ; 
specialRegister
  :'CR0' | 'CR2' | 'CR3' | 'DR0' | 'DR1' | 'DR2' | 'DR3' | 'DR6' | 'DR7'| 'TR3' | 'TR4' | 'TR5' | 'TR6' | 'TR7'
  ; 
stackOption
  :"NEARSTACK" | "FARSTACK" 
  ; 
startupDir
  :_STARTUP lineReminder
  ; 
stext
  :stringChar+
  ; 
string
  :quote  stext?  quote
  ; 
structBody
  : structItem structBody | structItem lineReminder
  ; 
commanonuniq
  :"," "NONUNIQUE"
  ;
structDir
  :structTag structHdr  fieldAlign?  commanonuniq? lineReminder structBody structTag "ENDS" lineReminder
  ; 
structHdr
  :"STRUC" | "STRUCT" | "UNION" 
  ; 
structInstance
  :"<"  fieldInitList?  ">"| "{" lineReminder?   fieldInitList?   lineReminder?  "}"| constExpr "DUP" "(" structInstList ")"
  ; 
structInstList
  :structInstance| structInstance  ","  lineReminder?  structInstList
  ; 
structItem 
  :dataDir| generalDir| offsetDir| nestedStruct
  ; 
structTag
  :id
  ; 
term
  : "!" simpleExpr | simpleExpr
  ; 
text
  : "!" character text| "!" character| textLiteral | character+
  ; 
textDir
  :id textMacroDir lineReminder
  ; 
textItem
  :textLiteral| "%" constExpr| textMacroId
  ; 
textLen
  :constExpr
  ; 
textList
  : textItem  "," lineReminder?  textList | textItem
  ; 
textLiteral
  :"<" text ">" lineReminder
  ; 
commatextLen
  :"," textLen
  ;
textStartcomma
  :textStart  ","
  ;
textMacroDir
  :"CATSTR" textList? | "TEXTEQU" textList? | "SIZESTR" textItem| "SUBSTR" textItem  "," textStart commatextLen| "INSTR" textStartcomma? textItem  "," textItem
  ; 
textMacroId
  :id
  ; 
textStart
  :constExpr
  ; 
titleDir
  :titleType arbitraryText lineReminder
  ; 
titleType
  :"TITLE" | "SUBTITLE" | "SUBTTL" 
  ; 
type
  :structTag| unionTag| recordTag| distance| dataType| typeId
  ; 
typedefDir
  :typeId "TYPEDEF" qualifier
  ; 
typeId
  :id
  ; 
unionTag
  :id
  ; 
untilDir
  :_UNTIL cExpr lineReminder _UNTILCXZ cxzExpr?  lineReminder
  ; 
usesRegs
  :"USES" regList 
  ; 
whileBlock
  :_WHILE cExpr lineReminder blockStatements lineReminder _ENDW 
  ; 
terminals
radixOverride
  :/[hoqtyHOQTY]/
  ; 
character
  :/[^\n\r]/
  ; 
comment
  :/;[^\n\r]*/
  ; 
stringChar
  :/(\'\')|(\"\")|[^\'\"]/
  ; 
decdigit
  :/\d/
  ; 
hexdigit
  :/[A-Fa-f]/
  ; 
id
  :/[A-Za-z]+\d*/
  ; 
delimiter
  :/[^\b\t\v\f\n\r\x1a\s\d]/
  ; 
whiteSpaceCharacter
  :/[\b\t\v\f\x1a\s]/
  ;
endOfLine
  :/[\r\n]+/
  ;
_186: ".186";
_286: ".286";
_286C: ".286C";
_286P: ".286P";
_287: ".287";
_386: ".386";
_386C: ".386C";
_386P: ".386P";
_387: ".387";
_486: ".486";
_486P: ".486P";
_586: ".586";
_586P: ".586P";
_686: ".686";
_686P: ".686P";
_8086: ".8086";
_8087: ".8087";
_ALPHA: ".ALPHA";
_BREAK: ".BREAK";
_CODE: ".CODE";
_CONST: ".CONST";
_CONTINUE: ".CONTINUE";
_CREF: ".CREF";
_DATA: ".DATA";
_DOSSEG: ".DOSSEG";
_ELSE: ".ELSE";
_ELSEIF: ".ELSEIF";
_ENDIF: ".ENDIF";
_ENDW: ".ENDW";
_ERR: ".ERR";
_ERR1: ".ERR1";
_ERR2: ".ERR2";
_ERRB: ".ERRB";
_ERRDEF: ".ERRDEF";
_ERRDIF: ".ERRDIF";
_ERRDIFI: ".ERRDIFI";
_ERRE: ".ERRE";
_ERRIDN: ".ERRIDN";
_ERRIDNI: ".ERRIDNI";
_ERRNB: ".ERRNB";
_ERRNDEF: ".ERRNDEF";
_ERRNZ: ".ERRNZ";
_EXIT: ".EXIT";
_FARDATA: ".FARDATA";
_IF: ".IF";
_K3D: ".K3D";
_LALL: ".LALL";
_LFCOND: ".LFCOND";
_LIST: ".LIST";
_LISTALL: ".LISTALL";
_LISTIF: ".LISTIF";
_LISTMACRO: ".LISTMACRO";
_LISTMACROALL: ".LISTMACROALL";
_MMX: ".MMX";
_MODEL: ".MODEL";
_NO87: ".NO87";
_NOCREF: ".NOCREF";
_NOLIST: ".NOLIST";
_NOLISTIF: ".NOLISTIF";
_NOLISTMACRO: ".NOLISTMACRO";
_RADIX: ".RADIX";
_REPEAT: ".REPEAT";
_SALL: ".SALL";
_SEQ: ".SEQ";
_SFCOND: ".SFCOND";
_STACK: ".STACK";
_STARTUP: ".STARTUP";
_TFCOND: ".TFCOND";
_TYPE: ".TYPE";
_UNTIL: ".UNTIL";
_UNTILCXZ: ".UNTILCXZ";
_WHILE: ".WHILE";
_XALL: ".XALL";
_XCREF: ".XCREF";
_XLIST: ".XLIST";
_XMM: ".XMM";
_DOT: ".";
_DATA_: ".DATA?";
_FARDATA_: ".FARDATA?";
